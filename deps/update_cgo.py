#!/usr/bin/env python3
import argparse
import glob
import os.path

argp = argparse.ArgumentParser()
argp.add_argument("--root-module", default="github.com/tommie/v8go")
argp.add_argument("--cgo-path-template", default="cgo_{os}_{arch}.go")
argp.add_argument("--manifest-paths", default="deps/*_*/libmanifest")
argp.add_argument("--min-go-version", default="1.19")
args = argp.parse_args()

def get_libs(manifest_path):
    with open(manifest_path, "rt") as f:
        return f.read().splitlines()

def get_all_libs(manifest_glob):
    for manifest_path in glob.glob(manifest_glob):
        os_arch = os.path.basename(os.path.dirname(manifest_path))
        os_arch = os_arch.split("_", 1)
        libs = get_libs(manifest_path)
        yield os_arch, manifest_path, libs

def format_ldflags_libs(os, arch, libs):
    # Since libraries are split without caring about dependencies,
    # we need to make it a group.
    #
    # Go explicitly allows start-group: https://cs.opensource.google/go/go/+/master:src/cmd/go/internal/work/security.go;l=205;drc=bc9da01e9d7de25f04173f7122e09fe0996aaa05
    #
    # However, XCode ld(1) does not support it, but says it "will continually search a static library": https://keith.github.io/xcode-man-pages/ld.1.html
    start_group = "-Wl,--start-group " if os != "darwin" else ""
    end_group = " -Wl,--end-group" if os != "darwin" else ""
    return (start_group +
        " ".join("-l{}".format(lib.replace(".a", "").replace("libv8", "v8")) for lib in libs) +
        end_group)

def generate_imported_mod_file(path, root_module, os, arch, min_go_version):
    with open(path, "wt") as f:
        f.write(IMPORTED_MOD_TMPL.format(root=root_module, os=os, arch=arch, min_go_version=min_go_version))

IMPORTED_MOD_TMPL = """// Generated by deps/update_cgo.py.
module {root}/deps/{os}_{arch}

go {min_go_version}
"""

def generate_imported_go_file(path, os, arch, ldflags):
    with open(path, "wt") as f:
        f.write(IMPORTED_GO_TMPL.format(os=os, arch=arch, ldflags=ldflags))

IMPORTED_GO_TMPL = """// Generated by deps/update_cgo.py.

package {os}_{arch}

// #cgo CXXFLAGS: -fno-rtti -fPIC -std=c++17 -I${{SRCDIR}}/../include -Wall
// #cgo CXXFLAGS: -DV8_COMPRESS_POINTERS -DV8_31BIT_SMIS_ON_64BIT_ARCH -DV8_ENABLE_SANDBOX
// #cgo LDFLAGS: -pthread -L${{SRCDIR}}
// #cgo LDFLAGS: {ldflags}
// #cgo libgcompat LDFLAGS: -lgcompat
// #cgo linux LDFLAGS: -ldl
import "C"
"""

def generate_importing_go_file(path, root_module, os, arch):
    with open(path, "wt") as f:
        f.write(IMPORTING_GO_TMPL.format(root=root_module, os=os, arch=arch))

IMPORTING_GO_TMPL = """// Generated by deps/update_cgo.py.
//go:build cgo && {os} && {arch}

package v8go

// Ensure the appropriate cgo library is pulled in.
import _ "{root}/deps/{os}_{arch}"
"""

def main():
    for (os_, arch), manifest_path, libs in get_all_libs(args.manifest_paths):
        generate_imported_mod_file(
            os.path.join(os.path.dirname(manifest_path), "go.mod"),
            args.root_module.format(os=os_, arch=arch),
            os_,
            arch,
            args.min_go_version)

        generate_imported_go_file(
            os.path.join(os.path.dirname(manifest_path), "cgo.go"),
            os_,
            arch,
            format_ldflags_libs(os_, arch, libs))

        generate_importing_go_file(
            args.cgo_path_template.format(os=os_, arch=arch),
            args.root_module.format(os=os_, arch=arch),
            os_,
            arch)


if __name__ == "__main__":
    main()
